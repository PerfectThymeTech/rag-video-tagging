{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"workspaceName": {
			"type": "string",
			"metadata": "Workspace name",
			"defaultValue": "tstsynapse4"
		},
		"tstsynapse4-WorkspaceDefaultSqlServer_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'tstsynapse4-WorkspaceDefaultSqlServer'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=tcp:tstsynapse4.sql.azuresynapse.net,1433;Initial Catalog=@{linkedService().DBName}"
		},
		"AzureAiSpeech_properties_typeProperties_subscriptionId": {
			"type": "string",
			"defaultValue": "8f171ff9-2b5b-4f0f-aed5-7fa360a1d094"
		},
		"AzureKeyVault_properties_typeProperties_baseUrl": {
			"type": "string",
			"defaultValue": "https://mabuss-cog-kv.vault.azure.net/"
		},
		"AzureOpenAi_properties_typeProperties_subscriptionId": {
			"type": "string",
			"defaultValue": "8f171ff9-2b5b-4f0f-aed5-7fa360a1d094"
		},
		"DataLakeCurated_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://tstsynapsestg.dfs.core.windows.net/"
		},
		"DataLakeExternal_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://tstsynapsestg.dfs.core.windows.net/"
		},
		"DataLakeRaw_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://tstsynapsestg.dfs.core.windows.net/"
		},
		"DataLakeWorkspace_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://tstsynapsestg.dfs.core.windows.net/"
		},
		"tstsynapse4-WorkspaceDefaultStorage_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://tstsynapsestg.dfs.core.windows.net"
		},
		"ExternalBlobTrigger_properties_MainPipeline_parameters_triggerFilePath": {
			"type": "string",
			"defaultValue": "@triggerBody().folderPath"
		},
		"ExternalBlobTrigger_properties_MainPipeline_parameters_triggerFileName": {
			"type": "string",
			"defaultValue": "@triggerBody().fileName"
		},
		"ExternalBlobTrigger_properties_typeProperties_scope": {
			"type": "string",
			"defaultValue": "/subscriptions/8f171ff9-2b5b-4f0f-aed5-7fa360a1d094/resourceGroups/test-purview/providers/Microsoft.Storage/storageAccounts/tstsynapsestg"
		}
	},
	"variables": {
		"workspaceId": "[concat('Microsoft.Synapse/workspaces/', parameters('workspaceName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('workspaceName'), '/ExternalToRawPipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Pipeline for moving data from external to the raw layer.",
				"activities": [
					{
						"name": "ReturnVariables",
						"description": "Return variables to main pipeline.",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "CopyExternalToRaw",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "pipelineReturnValue",
							"value": [
								{
									"key": "rawAdlsFilePath",
									"value": {
										"type": "Expression",
										"content": "@json(activity('CopyExternalToRaw').output.status.Output.result.exitValue).sink_adls_path"
									}
								},
								{
									"key": "rawAccountName",
									"value": {
										"type": "Expression",
										"content": "@json(activity('CopyExternalToRaw').output.status.Output.result.exitValue).sink_account_name"
									}
								},
								{
									"key": "rawContainerName",
									"value": {
										"type": "Expression",
										"content": "@json(activity('CopyExternalToRaw').output.status.Output.result.exitValue).sink_container_name"
									}
								},
								{
									"key": "rawDirectoryName",
									"value": {
										"type": "Expression",
										"content": "@json(activity('CopyExternalToRaw').output.status.Output.result.exitValue).sink_directory_name"
									}
								}
							],
							"setSystemVariable": true
						}
					},
					{
						"name": "CopyExternalToRaw",
						"description": "Copy File from External to Raw",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "CopyFile",
								"type": "NotebookReference"
							},
							"parameters": {
								"delete_source_file": {
									"value": {
										"value": "@variables('deleteSourceFile')",
										"type": "Expression"
									},
									"type": "bool"
								},
								"source_account_name": {
									"value": {
										"value": "@pipeline().parameters.externalAccountName",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_container_name": {
									"value": {
										"value": "@pipeline().parameters.externalContainerName",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_directory_name": {
									"value": {
										"value": "@pipeline().parameters.externalDirectoryName",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_file_name": {
									"value": {
										"value": "@pipeline().parameters.externalFileName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_account_name": {
									"value": {
										"value": "@pipeline().parameters.rawAccountName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_container_name": {
									"value": {
										"value": "@pipeline().parameters.rawContainerName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_directory_name": {
									"value": {
										"value": "@pipeline().parameters.rawDirectoryName",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "test",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Small",
							"conf": {
								"spark.dynamicAllocation.enabled": true
							},
							"driverSize": "Small"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"externalContainerName": {
						"type": "string"
					},
					"externalDirectoryName": {
						"type": "string"
					},
					"externalFileName": {
						"type": "string"
					},
					"rawContainerName": {
						"type": "string"
					},
					"rawDirectoryName": {
						"type": "string"
					},
					"externalAccountName": {
						"type": "string"
					},
					"rawAccountName": {
						"type": "string"
					}
				},
				"variables": {
					"deleteSourceFile": {
						"type": "Boolean",
						"defaultValue": true
					}
				},
				"folder": {
					"name": "ChildPipelines"
				},
				"annotations": [],
				"lastPublishTime": "2024-03-06T17:33:23Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/CopyFile')]",
				"[concat(variables('workspaceId'), '/bigDataPools/test')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MainPipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ExecuteExternalToRawPipeline",
						"description": "Execute External to Raw Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "ExecuteParseTriggerPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "ExternalToRawPipeline",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"externalContainerName": {
									"value": "@string(activity('ExecuteParseTriggerPipeline').output.pipelineReturnValue.externalContainerName)",
									"type": "Expression"
								},
								"externalDirectoryName": {
									"value": "@string(activity('ExecuteParseTriggerPipeline').output.pipelineReturnValue.externalDirectoryName)",
									"type": "Expression"
								},
								"externalFileName": {
									"value": "@string(activity('ExecuteParseTriggerPipeline').output.pipelineReturnValue.externalFileName)",
									"type": "Expression"
								},
								"rawContainerName": {
									"value": "@variables('rawContainerName')",
									"type": "Expression"
								},
								"rawDirectoryName": {
									"value": "@string('')",
									"type": "Expression"
								},
								"externalAccountName": {
									"value": "@variables('externalAccountName')",
									"type": "Expression"
								},
								"rawAccountName": {
									"value": "@variables('rawAccountName')",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "ExecuteRawToCuratedPipeline",
						"description": "Execute Raw to Curated Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "ExecuteExternalToRawPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "RawToCuratedPipeline",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"newsShowDetails": {
									"value": "@string('')",
									"type": "Expression"
								},
								"rawAccountName": {
									"value": "@string(activity('ExecuteExternalToRawPipeline').output.pipelineReturnValue.rawAccountName)",
									"type": "Expression"
								},
								"rawContainerName": {
									"value": "@string(activity('ExecuteExternalToRawPipeline').output.pipelineReturnValue.rawContainerName)",
									"type": "Expression"
								},
								"rawDirectoryName": {
									"value": "@string(activity('ExecuteExternalToRawPipeline').output.pipelineReturnValue.rawDirectoryName)",
									"type": "Expression"
								},
								"curatedAccountName": {
									"value": "@variables('curatedAccountName')",
									"type": "Expression"
								},
								"curatedContainerName": {
									"value": "@variables('curatedContainerName')",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "ExecuteParseTriggerPipeline",
						"description": "Execute Pipeline to parse trigger information",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "ParseTriggerPipeline",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"triggerFilePath": {
									"value": "@pipeline().parameters.triggerFilePath",
									"type": "Expression"
								},
								"triggerFileName": {
									"value": "@pipeline().parameters.triggerFileName",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "ExecutePushToMetdataStorePipeline",
						"description": "Execute Pipeline to push to metadata store",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "ExecuteRawToCuratedPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "PushToMetdataStorePipeline",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"triggerFilePath": {
						"type": "string"
					},
					"triggerFileName": {
						"type": "string"
					}
				},
				"variables": {
					"externalAccountName": {
						"type": "String",
						"defaultValue": "tstsynapsestg"
					},
					"externalContainerName": {
						"type": "String",
						"defaultValue": "external"
					},
					"rawAccountName": {
						"type": "String",
						"defaultValue": "tstsynapsestg"
					},
					"rawContainerName": {
						"type": "String",
						"defaultValue": "raw"
					},
					"rawDirectoryName": {
						"type": "String"
					},
					"curatedAccountName": {
						"type": "String",
						"defaultValue": "tstsynapsestg"
					},
					"curatedContainerName": {
						"type": "String",
						"defaultValue": "curated"
					}
				},
				"annotations": [],
				"lastPublishTime": "2024-03-06T17:33:50Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/ExternalToRawPipeline')]",
				"[concat(variables('workspaceId'), '/pipelines/RawToCuratedPipeline')]",
				"[concat(variables('workspaceId'), '/pipelines/ParseTriggerPipeline')]",
				"[concat(variables('workspaceId'), '/pipelines/PushToMetdataStorePipeline')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ParseTriggerPipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Pipeline to parse trigger details.",
				"activities": [
					{
						"name": "SetExternalContainerNameVariable",
						"description": "Set variable \"externalContainerName\"",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "externalContainerName",
							"value": {
								"value": "@first(split(pipeline().parameters.triggerFilePath, '/'))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ReturnVariables",
						"description": "Return variables to main pipeline.",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "SetExternalContainerNameVariable",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "pipelineReturnValue",
							"value": [
								{
									"key": "externalContainerName",
									"value": {
										"type": "Expression",
										"content": "@variables('externalContainerName')"
									}
								},
								{
									"key": "externalDirectoryName",
									"value": {
										"type": "Expression",
										"content": "@replace(pipeline().parameters.triggerFilePath, concat(variables('externalContainerName'), '/'), '')"
									}
								},
								{
									"key": "externalFileName",
									"value": {
										"type": "Expression",
										"content": "@pipeline().parameters.triggerFileName"
									}
								}
							],
							"setSystemVariable": true
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"triggerFilePath": {
						"type": "string"
					},
					"triggerFileName": {
						"type": "string"
					}
				},
				"variables": {
					"externalContainerName": {
						"type": "String"
					},
					"externalDirectoryName": {
						"type": "String"
					},
					"externalFileName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "ChildPipelines"
				},
				"annotations": [],
				"lastPublishTime": "2024-03-06T17:32:46Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PushToMetdataStorePipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Pipeline to ush results to metadata store",
				"activities": [
					{
						"name": "DummyWait",
						"type": "Wait",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"waitTimeInSeconds": 1
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "ChildPipelines"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RawToCuratedPipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Pipeline for moving data from raw to the curated layer.",
				"activities": [
					{
						"name": "ProcessNewsVideo",
						"description": "Process Video file stored in raw layer.",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "ProcessNewsVideo",
								"type": "NotebookReference"
							},
							"parameters": {
								"news_show_details": {
									"value": {
										"value": "@pipeline().parameters.newsShowDetails",
										"type": "Expression"
									},
									"type": "string"
								},
								"azure_ai_speech_linked_service_name": {
									"value": {
										"value": "@variables('azureAiSpeechLinkedServiceName')",
										"type": "Expression"
									},
									"type": "string"
								},
								"azure_ai_speech_region": {
									"value": {
										"value": "@variables('azureAiSpeechRegion')",
										"type": "Expression"
									},
									"type": "string"
								},
								"azure_open_ai_linked_service_name": {
									"value": {
										"value": "@variables('azureOpenAiLinkedServiceName')",
										"type": "Expression"
									},
									"type": "string"
								},
								"azure_open_ai_base_url": {
									"value": {
										"value": "@variables('azureOpenAiBaseUrl')",
										"type": "Expression"
									},
									"type": "string"
								},
								"azure_open_ai_api_version": {
									"value": {
										"value": "@variables('azureOpenAiApiVersion')",
										"type": "Expression"
									},
									"type": "string"
								},
								"azure_open_ai_deployment_name": {
									"value": {
										"value": "@variables('azureOpenAiDeploymentName')",
										"type": "Expression"
									},
									"type": "string"
								},
								"azure_open_ai_model_name": {
									"value": {
										"value": "@variables('azureOpenAiModelName')",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_linked_service_name": {
									"value": {
										"value": "@variables('rawLinkedServiceName')",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_mount_path": {
									"value": {
										"value": "@variables('rawMountPath')",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_account_name": {
									"value": {
										"value": "@pipeline().parameters.rawAccountName",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_container_name": {
									"value": {
										"value": "@pipeline().parameters.rawContainerName",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_file_path": {
									"value": {
										"value": "@pipeline().parameters.rawDirectoryName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_linked_service_name": {
									"value": {
										"value": "@variables('curatedLinkedServiceName')",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_mount_path": {
									"value": {
										"value": "@variables('curatedMountPath')",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_account_name": {
									"value": {
										"value": "@pipeline().parameters.curatedAccountName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_container_name": {
									"value": {
										"value": "@pipeline().parameters.curatedContainerName",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "test",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Medium",
							"conf": {
								"spark.dynamicAllocation.enabled": true
							},
							"driverSize": "Medium"
						}
					},
					{
						"name": "ReturnVariables",
						"description": "Return variables to main pipeline.",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ProcessNewsVideo",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "pipelineReturnValue",
							"value": [
								{
									"key": "curatedAdlsFilePath",
									"value": {
										"type": "Expression",
										"content": "@json(activity('ProcessNewsVideo').output.status.Output.result.exitValue).sink_adls_path"
									}
								},
								{
									"key": "curatedAccountName",
									"value": {
										"type": "Expression",
										"content": "@json(activity('ProcessNewsVideo').output.status.Output.result.exitValue).sink_account_name"
									}
								},
								{
									"key": "curatedContainerName",
									"value": {
										"type": "Expression",
										"content": "@json(activity('ProcessNewsVideo').output.status.Output.result.exitValue).sink_container_name"
									}
								},
								{
									"key": "curatedDirectoryName",
									"value": {
										"type": "Expression",
										"content": "@json(activity('ProcessNewsVideo').output.status.Output.result.exitValue).sink_directory_name"
									}
								}
							],
							"setSystemVariable": true
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"newsShowDetails": {
						"type": "string"
					},
					"rawAccountName": {
						"type": "string"
					},
					"rawContainerName": {
						"type": "string"
					},
					"rawDirectoryName": {
						"type": "string"
					},
					"curatedAccountName": {
						"type": "string"
					},
					"curatedContainerName": {
						"type": "string"
					}
				},
				"variables": {
					"azureAiSpeechLinkedServiceName": {
						"type": "String",
						"defaultValue": "AzureAiSpeech"
					},
					"azureAiSpeechRegion": {
						"type": "String",
						"defaultValue": "swedencentral"
					},
					"azureOpenAiLinkedServiceName": {
						"type": "String",
						"defaultValue": "AzureOpenAi"
					},
					"azureOpenAiBaseUrl": {
						"type": "String",
						"defaultValue": "https://aoai-swedencentral-mabuss.openai.azure.com/"
					},
					"azureOpenAiApiVersion": {
						"type": "String",
						"defaultValue": "2023-05-15"
					},
					"azureOpenAiDeploymentName": {
						"type": "String",
						"defaultValue": "gpt-4-32k"
					},
					"azureOpenAiModelName": {
						"type": "String",
						"defaultValue": "gpt-4-32k"
					},
					"rawMountPath": {
						"type": "String",
						"defaultValue": "raw"
					},
					"curatedMountPath": {
						"type": "String",
						"defaultValue": "curated"
					},
					"rawLinkedServiceName": {
						"type": "String",
						"defaultValue": "DataLakeRaw"
					},
					"curatedLinkedServiceName": {
						"type": "String",
						"defaultValue": "DataLakeCurated"
					}
				},
				"folder": {
					"name": "ChildPipelines"
				},
				"annotations": [],
				"lastPublishTime": "2024-03-06T15:20:16Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/ProcessNewsVideo')]",
				"[concat(variables('workspaceId'), '/bigDataPools/test')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestCopyNotebook')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "TestCopyNotebook",
						"description": "Copy File from External to Raw",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "CopyFile",
								"type": "NotebookReference"
							},
							"parameters": {
								"delete_source_file": {
									"value": {
										"value": "@pipeline().parameters.deleteSourceFile",
										"type": "Expression"
									},
									"type": "bool"
								},
								"source_account_name": {
									"value": {
										"value": "@pipeline().parameters.sourceAccountName",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_container_name": {
									"value": {
										"value": "@pipeline().parameters.sourceContainerName",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_directory_name": {
									"value": {
										"value": "@string('')",
										"type": "Expression"
									},
									"type": "string"
								},
								"source_file_name": {
									"value": {
										"value": "@pipeline().parameters.sourceFileName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_account_name": {
									"value": {
										"value": "@pipeline().parameters.sinkAccountName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_container_name": {
									"value": {
										"value": "@pipeline().parameters.sinkContainerName",
										"type": "Expression"
									},
									"type": "string"
								},
								"sink_directory_name": {
									"value": {
										"value": "@string('')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "test",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Small",
							"conf": {
								"spark.dynamicAllocation.enabled": true
							},
							"driverSize": "Small"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"deleteSourceFile": {
						"type": "bool",
						"defaultValue": true
					},
					"sourceAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"sourceContainerName": {
						"type": "string",
						"defaultValue": "raw"
					},
					"sourceDirectoryName": {
						"type": "string"
					},
					"sourceFileName": {
						"type": "string",
						"defaultValue": "movie.mp4"
					},
					"sinkAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"sinkContainerName": {
						"type": "string",
						"defaultValue": "raw"
					},
					"sinkDirectoryName": {
						"type": "string"
					}
				},
				"folder": {
					"name": "Tests"
				},
				"annotations": [],
				"lastPublishTime": "2024-03-06T14:35:56Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/CopyFile')]",
				"[concat(variables('workspaceId'), '/bigDataPools/test')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestExternalParseTriggerPipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Test Pipeline for parsing trigger details",
				"activities": [
					{
						"name": "ExecuteParseTriggerPipeline",
						"description": "Execute Pipeline to parse trigger information",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "ParseTriggerPipeline",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"triggerFilePath": {
									"value": "@pipeline().parameters.triggerFilePath",
									"type": "Expression"
								},
								"triggerFileName": {
									"value": "@pipeline().parameters.triggerFileName",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "GetPipelineVariableExternalContainerName",
						"description": "Get Pipeline Variable \"externalContainerName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteParseTriggerPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "externalContainerName",
							"value": {
								"value": "@string(activity('ExecuteParseTriggerPipeline').output.pipelineReturnValue.externalContainerName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableExternalDirectoryName",
						"description": "Get Pipeline Variable \"externalDirectoryName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteParseTriggerPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "externalDirectoryName",
							"value": {
								"value": "@string(activity('ExecuteParseTriggerPipeline').output.pipelineReturnValue.externalDirectoryName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableExternalFileName",
						"description": "Get Pipeline Variable \"externalFileName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteParseTriggerPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "externalFileName",
							"value": {
								"value": "@string(activity('ExecuteParseTriggerPipeline').output.pipelineReturnValue.externalFileName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "IfExternalContainerName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableExternalContainerName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('externalContainerName'), pipeline().parameters.expectedExternalContainerName)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailExternalContainerName",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfExternalDirectoryName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableExternalDirectoryName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('externalDirectoryName'), pipeline().parameters.expectedExternalDirectoryName)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailExternalContainerName_copy1",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfExternalFileName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableExternalFileName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('externalFileName'), pipeline().parameters.expectedExternalFileName)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailExternalContainerName_copy1_copy1",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"triggerFilePath": {
						"type": "string",
						"defaultValue": "external/directory001"
					},
					"triggerFileName": {
						"type": "string",
						"defaultValue": "movie.mp4"
					},
					"expectedExternalContainerName": {
						"type": "string",
						"defaultValue": "external"
					},
					"expectedExternalDirectoryName": {
						"type": "string",
						"defaultValue": "directory001"
					},
					"expectedExternalFileName": {
						"type": "string",
						"defaultValue": "movie.mp4"
					}
				},
				"variables": {
					"externalContainerName": {
						"type": "String"
					},
					"externalDirectoryName": {
						"type": "String"
					},
					"externalFileName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "Tests"
				},
				"annotations": [],
				"lastPublishTime": "2024-03-06T15:26:39Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/ParseTriggerPipeline')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestExternalToRawPipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ExecuteExternalToRawPipeline",
						"description": "Execute External to Raw Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "ExternalToRawPipeline",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"externalContainerName": {
									"value": "@pipeline().parameters.externalContainerName",
									"type": "Expression"
								},
								"externalDirectoryName": {
									"value": "@string('')",
									"type": "Expression"
								},
								"externalFileName": {
									"value": "@pipeline().parameters.externalFileName",
									"type": "Expression"
								},
								"rawContainerName": {
									"value": "@pipeline().parameters.rawContainerName",
									"type": "Expression"
								},
								"rawDirectoryName": {
									"value": "@string('')",
									"type": "Expression"
								},
								"externalAccountName": {
									"value": "@pipeline().parameters.externalAccountName",
									"type": "Expression"
								},
								"rawAccountName": {
									"value": "@pipeline().parameters.rawAccountName",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "GetPipelineVariableRawAdlsFilePath",
						"description": "Get Pipeline Variable \"rawAdlsFilePath\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteExternalToRawPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rawAdlsFilePath",
							"value": {
								"value": "@string(activity('ExecuteExternalToRawPipeline').output.pipelineReturnValue.rawAdlsFilePath)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableRawAccountName",
						"description": "Get Pipeline Variable \"rawAccountName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteExternalToRawPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rawAccountName",
							"value": {
								"value": "@string(activity('ExecuteExternalToRawPipeline').output.pipelineReturnValue.rawAccountName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableRawContainerName",
						"description": "Get Pipeline Variable \"rawContainerName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteExternalToRawPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rawContainerName",
							"value": {
								"value": "@string(activity('ExecuteExternalToRawPipeline').output.pipelineReturnValue.rawContainerName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableRawDirectoryName",
						"description": "Get Pipeline Variable \"rawDirectoryName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteExternalToRawPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "rawDirectoryName",
							"value": {
								"value": "@string(activity('ExecuteExternalToRawPipeline').output.pipelineReturnValue.rawDirectoryName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "IfRawAdlsFilePath",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableRawAdlsFilePath",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rawAdlsFilePath'), replace(pipeline().parameters.expectedRawAdlsFilePath, '<pipeline-id>', activity('ExecuteExternalToRawPipeline').output.pipelineRunId))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawAdlsFilePath",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfRawAccountName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableRawAccountName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rawAccountName'), pipeline().parameters.expectedRawAccountName)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawAccountName",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfRawContainerName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableRawContainerName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rawContainerName'), pipeline().parameters.expectedRawContainerName)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawContainerName",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfRawDirectoryName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableRawDirectoryName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('rawDirectoryName'), replace(pipeline().parameters.expectedRawDirectoryName, '<pipeline-id>', activity('ExecuteExternalToRawPipeline').output.pipelineRunId))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawDirectoryName",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"externalContainerName": {
						"type": "string",
						"defaultValue": "external"
					},
					"externalDirectoryName": {
						"type": "string"
					},
					"externalFileName": {
						"type": "string",
						"defaultValue": "movie.mp4"
					},
					"rawContainerName": {
						"type": "string",
						"defaultValue": "raw"
					},
					"rawDirectoryName": {
						"type": "string"
					},
					"externalAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"rawAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"expectedRawAdlsFilePath": {
						"type": "string",
						"defaultValue": "abfss://raw@tstsynapsestg.dfs.core.windows.net/<pipeline-id>//movie.mp4"
					},
					"expectedRawAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"expectedRawContainerName": {
						"type": "string",
						"defaultValue": "raw"
					},
					"expectedRawDirectoryName": {
						"type": "string",
						"defaultValue": "<pipeline-id>//movie.mp4"
					}
				},
				"variables": {
					"rawAdlsFilePath": {
						"type": "String"
					},
					"rawAccountName": {
						"type": "String"
					},
					"rawContainerName": {
						"type": "String"
					},
					"rawDirectoryName": {
						"type": "String"
					},
					"test": {
						"type": "String"
					}
				},
				"folder": {
					"name": "Tests"
				},
				"annotations": [],
				"lastPublishTime": "2024-03-06T15:26:39Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/ExternalToRawPipeline')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestRawToCuratedPipeline')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ExecuteRawToCuratedPipeline",
						"description": "Execute Raw to Curated Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "RawToCuratedPipeline",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"newsShowDetails": {
									"value": "@pipeline().parameters.newsShowDetails",
									"type": "Expression"
								},
								"rawAccountName": {
									"value": "@pipeline().parameters.rawAccountName",
									"type": "Expression"
								},
								"rawContainerName": {
									"value": "@pipeline().parameters.rawContainerName",
									"type": "Expression"
								},
								"rawDirectoryName": {
									"value": "@pipeline().parameters.rawDirectoryName",
									"type": "Expression"
								},
								"curatedAccountName": {
									"value": "@pipeline().parameters.curatedAccountName",
									"type": "Expression"
								},
								"curatedContainerName": {
									"value": "@pipeline().parameters.curatedContainerName",
									"type": "Expression"
								}
							}
						}
					},
					{
						"name": "GetPipelineVariableCuratedAdlsFilePath",
						"description": "Get Pipeline Variable \"curatedAdlsFilePath\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteRawToCuratedPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "curatedAdlsFilePath",
							"value": {
								"value": "@string(activity('ExecuteRawToCuratedPipeline').output.pipelineReturnValue.curatedAdlsFilePath)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableCuratedAccountName",
						"description": "Get Pipeline Variable \"curatedAccountName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteRawToCuratedPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "curatedAccountName",
							"value": {
								"value": "@string(activity('ExecuteRawToCuratedPipeline').output.pipelineReturnValue.curatedAccountName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableCuratedContainerName",
						"description": "Get Pipeline Variable \"curatedContainerName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteRawToCuratedPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "curatedContainerName",
							"value": {
								"value": "@string(activity('ExecuteRawToCuratedPipeline').output.pipelineReturnValue.curatedContainerName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "GetPipelineVariableCuratedDirectoryName",
						"description": "Get Pipeline Variable \"curatedDirectoryName\"",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "ExecuteRawToCuratedPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "curatedDirectoryName",
							"value": {
								"value": "@string(activity('ExecuteRawToCuratedPipeline').output.pipelineReturnValue.curatedDirectoryName)",
								"type": "Expression"
							}
						}
					},
					{
						"name": "IfCuratedAdlsFilePath",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableCuratedAdlsFilePath",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('curatedAdlsFilePath'), replace(pipeline().parameters.expectedCuratedAdlsFilePath, '<pipeline-id>', activity('ExecuteRawToCuratedPipeline').output.pipelineRunId))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawAdlsFilePath",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfCuratedAccountName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableCuratedAccountName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('curatedAccountName'), pipeline().parameters.expectedCuratedAccountName)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawAccountName",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfCuratedContainerName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableCuratedContainerName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('curatedContainerName'), pipeline().parameters.expectedCuratedContainerName)",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawContainerName",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					},
					{
						"name": "IfCuratedDirectoryName",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetPipelineVariableCuratedDirectoryName",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(variables('curatedDirectoryName'), replace(pipeline().parameters.expectedCuratedDirectoryName, '<pipeline-id>', activity('ExecuteRawToCuratedPipeline').output.pipelineRunId))",
								"type": "Expression"
							},
							"ifFalseActivities": [
								{
									"name": "FailRawDirectoryName",
									"type": "Fail",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"message": "Unexpected Value",
										"errorCode": "500"
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"newsShowDetails": {
						"type": "string",
						"defaultValue": "This is a news show."
					},
					"rawAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"rawContainerName": {
						"type": "string",
						"defaultValue": "raw"
					},
					"rawDirectoryName": {
						"type": "string",
						"defaultValue": "01004489-f156-47b3-88e3-661b3ddbd220/movie.mp4"
					},
					"curatedAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"curatedContainerName": {
						"type": "string",
						"defaultValue": "curated"
					},
					"expectedCuratedAdlsFilePath": {
						"type": "string",
						"defaultValue": "abfss://curated@tstsynapsestg.dfs.core.windows.net/<pipeline-id>/audio.wav"
					},
					"expectedCuratedAccountName": {
						"type": "string",
						"defaultValue": "tstsynapsestg"
					},
					"expectedCuratedContainerName": {
						"type": "string",
						"defaultValue": "curated"
					},
					"expectedCuratedDirectoryName": {
						"type": "string",
						"defaultValue": "<pipeline-id>/audio.wav"
					}
				},
				"variables": {
					"curatedAdlsFilePath": {
						"type": "String"
					},
					"curatedAccountName": {
						"type": "String"
					},
					"curatedContainerName": {
						"type": "String"
					},
					"curatedDirectoryName": {
						"type": "String"
					}
				},
				"folder": {
					"name": "Tests"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/RawToCuratedPipeline')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureAiSpeech')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "CognitiveService",
				"typeProperties": {
					"subscriptionId": "[parameters('AzureAiSpeech_properties_typeProperties_subscriptionId')]",
					"resourceGroup": "fdfrgrf_group",
					"csName": "speech-mabuss",
					"csKind": "SpeechServices",
					"csLocation": "swedencentral",
					"endPoint": "https://swedencentral.api.cognitive.microsoft.com/",
					"csKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "AzureKeyVault",
							"type": "LinkedServiceReference"
						},
						"secretName": "speech-key"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/AzureKeyVault')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureKeyVault')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureKeyVault",
				"typeProperties": {
					"baseUrl": "[parameters('AzureKeyVault_properties_typeProperties_baseUrl')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureOpenAi')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "CognitiveService",
				"typeProperties": {
					"subscriptionId": "[parameters('AzureOpenAi_properties_typeProperties_subscriptionId')]",
					"resourceGroup": "fdfrgrf_group",
					"csName": "aoai-swedencentral-mabuss",
					"csKind": "OpenAI",
					"csLocation": "swedencentral",
					"endPoint": "https://aoai-swedencentral-mabuss.openai.azure.com/",
					"csKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "AzureKeyVault",
							"type": "LinkedServiceReference"
						},
						"secretName": "openai-key"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/AzureKeyVault')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DataLakeCurated')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('DataLakeCurated_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DataLakeExternal')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Data Lake to receive data.",
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('DataLakeExternal_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AzureIntegrationRuntime001",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AzureIntegrationRuntime001')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DataLakeRaw')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('DataLakeRaw_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DataLakeWorkspace')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('DataLakeWorkspace_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/tstsynapse4-WorkspaceDefaultSqlServer')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"DBName": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"connectionString": "[parameters('tstsynapse4-WorkspaceDefaultSqlServer_connectionString')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/tstsynapse4-WorkspaceDefaultStorage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('tstsynapse4-WorkspaceDefaultStorage_properties_typeProperties_url')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ExternalBlobTrigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "MainPipeline",
							"type": "PipelineReference"
						},
						"parameters": {
							"triggerFilePath": "[parameters('ExternalBlobTrigger_properties_MainPipeline_parameters_triggerFilePath')]",
							"triggerFileName": "[parameters('ExternalBlobTrigger_properties_MainPipeline_parameters_triggerFileName')]"
						}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/external/blobs/",
					"blobPathEndsWith": ".mp4",
					"ignoreEmptyBlobs": true,
					"scope": "[parameters('ExternalBlobTrigger_properties_typeProperties_scope')]",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/MainPipeline')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutoResolveIntegrationRuntime')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 0
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureIntegrationRuntime001')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"description": "Azure Integration Runtime 001",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 10,
							"cleanup": false,
							"customProperties": []
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/WorkspaceSystemIdentity')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ManagedIdentity",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CopyFile')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "test",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "67580919-9344-41d6-8333-41ef38d32c98"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/8f171ff9-2b5b-4f0f-aed5-7fa360a1d094/resourceGroups/test-purview/providers/Microsoft.Synapse/workspaces/tstsynapse4/bigDataPools/test",
						"name": "test",
						"type": "Spark",
						"endpoint": "https://tstsynapse4.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/test",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 10,
						"cores": 8,
						"memory": 56,
						"automaticScaleJobs": false
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# General parameters\r\n",
							"delete_source_file = True\r\n",
							"exit_notebook_with_outputs = True\r\n",
							"\r\n",
							"# Source storage parameters\r\n",
							"source_account_name = \"tstsynapsestg\"\r\n",
							"source_container_name = \"external\"\r\n",
							"source_directory_name = \"\"\r\n",
							"source_file_name = \"movie.mp4\"\r\n",
							"\r\n",
							"# Sink storage parameters\r\n",
							"sink_account_name = \"tstsynapsestg\"\r\n",
							"sink_container_name = \"raw\"\r\n",
							"sink_directory_name = \"\"\r\n",
							""
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Get Pipeline ID"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import uuid\r\n",
							"from notebookutils import mssparkutils\r\n",
							"\r\n",
							"pipeline_id = mssparkutils.runtime.context.get(\"pipelinejobid\")\r\n",
							"if not pipeline_id:\r\n",
							"    pipeline_id = f\"{uuid.uuid4()}\"\r\n",
							""
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(pipeline_id)"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Copy Data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Define source file path\r\n",
							"source_adls_path = f\"abfss://{source_container_name}@{source_account_name}.dfs.core.windows.net/{source_directory_name}/{source_file_name}\"\r\n",
							"\r\n",
							"# Define sink file path\r\n",
							"source_file_extension = source_file_name.split(\".\")[-1]\r\n",
							"sink_directory_name = f\"{pipeline_id}/{sink_directory_name}\"\r\n",
							"sink_file_name = f\"movie.{source_file_extension}\"\r\n",
							"sink_adls_path = f\"abfss://{sink_container_name}@{sink_account_name}.dfs.core.windows.net/{sink_directory_name}/{sink_file_name}\"\r\n",
							""
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"mssparkutils.fs.fastcp(\r\n",
							"    src=source_adls_path,\r\n",
							"    dest=sink_adls_path,\r\n",
							"    recurse=False\r\n",
							")\r\n",
							""
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Delete Source File"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"if delete_source_file:\r\n",
							"    mssparkutils.fs.rm(\r\n",
							"        dir=source_adls_path,\r\n",
							"        recurse=False\r\n",
							"    )\r\n",
							""
						],
						"outputs": [],
						"execution_count": 37
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Create outputs"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"outputs = {\r\n",
							"    \"sink_adls_path\": sink_adls_path,\r\n",
							"    \"sink_account_name\": sink_account_name,\r\n",
							"    \"sink_container_name\": sink_container_name,\r\n",
							"    \"sink_directory_name\": f\"{sink_directory_name}/{sink_file_name}\"\r\n",
							"}\r\n",
							"\r\n",
							"if exit_notebook_with_outputs:\r\n",
							"    mssparkutils.notebook.exit(\r\n",
							"        value=str(outputs)\r\n",
							"    )\r\n",
							""
						],
						"outputs": [],
						"execution_count": 46
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ProcessNewsVideo')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Process News Video using Azure AI Speech and Azure Open AI. ",
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "test",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "955c85d8-f27c-4a4e-8517-2694e3d7853c"
					}
				},
				"metadata": {
					"saveOutput": true,
					"synapse_widget": {
						"version": "0.1"
					},
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "/subscriptions/8f171ff9-2b5b-4f0f-aed5-7fa360a1d094/resourceGroups/test-purview/providers/Microsoft.Synapse/workspaces/tstsynapse4/bigDataPools/test",
						"name": "test",
						"type": "Spark",
						"endpoint": "https://tstsynapse4.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/test",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net",
							"authHeader": null
						},
						"sparkVersion": "3.3",
						"nodeCount": 10,
						"cores": 8,
						"memory": 56,
						"extraHeader": null
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# General parameters\r\n",
							"news_show_details=\"This is a german news show summarizing the events of the 15th February 2024.\"\r\n",
							"\r\n",
							"# Azure Speech \r\n",
							"azure_ai_speech_linked_service_name = \"AzureAiSpeech\"\r\n",
							"azure_ai_speech_region = \"swedencentral\"\r\n",
							"\r\n",
							"azure_open_ai_linked_service_name = \"AzureOpenAi\"\r\n",
							"azure_open_ai_base_url=\"https://aoai-swedencentral-mabuss.openai.azure.com/\"\r\n",
							"azure_open_ai_api_version=\"2023-05-15\"\r\n",
							"azure_open_ai_deployment_name=\"gpt-4-32k\"\r\n",
							"azure_open_ai_model_name=\"gpt-4-32k\"\r\n",
							"\r\n",
							"# Raw storage parameters\r\n",
							"raw_linked_service_name = \"AzureDataLakeStorage\"\r\n",
							"raw_mount_path = \"raw-videos\"\r\n",
							"\r\n",
							"raw_account_name = \"tstsynapsestg\"\r\n",
							"raw_container_name = \"video\"\r\n",
							"raw_file_path = \"movie.mp4\"\r\n",
							"\r\n",
							"# Curated storage parameters\r\n",
							"curated_linked_service_name = \"AzureDataLakeStorage\"\r\n",
							"curated_mount_path = \"curated-videos\"\r\n",
							"\r\n",
							"curated_account_name = \"tstsynapsestg\"\r\n",
							"curated_container_name = \"curated\"\r\n",
							"curated_file_path = \"movie.mp4\"\r\n",
							""
						],
						"outputs": [],
						"execution_count": 23
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Get Pipeline ID"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import uuid\r\n",
							"from notebookutils import mssparkutils\r\n",
							"\r\n",
							"pipeline_id = mssparkutils.runtime.context.get(\"pipelinejobid\")\r\n",
							"if not pipeline_id:\r\n",
							"    pipeline_id = f\"{uuid.uuid4()}\"\r\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(pipeline_id)"
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Mount Data Lake"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from notebookutils import mssparkutils\r\n",
							"\r\n",
							"\r\n",
							"def mount_datalake_gen2(account_name: str, container_name: str, mount_path: str, linked_service_name: str) -> str:\r\n",
							"    # Mount ADLS Gen2\r\n",
							"    mssparkutils.fs.mount( \r\n",
							"        f\"abfss://{container_name}@{account_name}.dfs.core.windows.net\", \r\n",
							"        f\"/{mount_path}\",\r\n",
							"        {\r\n",
							"            \"LinkedService\": linked_service_name,\r\n",
							"            \"fileCacheTimeout\": 120,\r\n",
							"            \"timeout\": 120\r\n",
							"        }\r\n",
							"    )\r\n",
							"\r\n",
							"    # Compute mount point and return value\r\n",
							"    mount_path_cluster = mssparkutils.fs.getMountPath(f\"/{mount_path}\")\r\n",
							"    return mount_path_cluster\r\n",
							"\r\n",
							"\r\n",
							"def unmount_datalake_gen2(mount_path: str) -> None:\r\n",
							"    mssparkutils.fs.unmount(f\"/{mount_path}\")\r\n",
							""
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Mount raw storage\r\n",
							"raw_mount_path_cluster = mount_datalake_gen2(\r\n",
							"    account_name=raw_account_name,\r\n",
							"    container_name=raw_container_name,\r\n",
							"    mount_path=raw_mount_path,\r\n",
							"    linked_service_name=raw_linked_service_name,\r\n",
							")\r\n",
							"\r\n",
							"# Mount curated storage\r\n",
							"curated_mount_path_cluster = mount_datalake_gen2(\r\n",
							"    account_name=curated_account_name,\r\n",
							"    container_name=curated_container_name,\r\n",
							"    mount_path=curated_mount_path,\r\n",
							"    linked_service_name=curated_linked_service_name,\r\n",
							")\r\n",
							""
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Extract Audio from Video"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import os\r\n",
							"\r\n",
							"from moviepy.editor import VideoFileClip, AudioFileClip\r\n",
							"\r\n",
							"\r\n",
							"def extract_audio_from_video(video_filepath: str, audio_filepath: str, audio_filename: str = \"audio.wav\") -> AudioFileClip:\r\n",
							"    # Load video file\r\n",
							"    video = VideoFileClip(\r\n",
							"        filename=video_filepath,\r\n",
							"        has_mask=False,\r\n",
							"        audio=True\r\n",
							"    )\r\n",
							"\r\n",
							"    # Get audio file path\r\n",
							"    os.makedirs(audio_filepath, exist_ok=True)\r\n",
							"    audio_filepath = os.path.join(audio_filepath, audio_filename)\r\n",
							"\r\n",
							"    # Extract, write and return audio\r\n",
							"    audio = video.audio\r\n",
							"    audio.write_audiofile(audio_filepath) #, nbytes=2, codec=\"pcm_s16le\", bitrate=\"16k\", ffmpeg_params=[\"-ac\", \"1\"])\r\n",
							"    return audio\r\n",
							""
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"video_filepath = f\"{raw_mount_path_cluster}/{raw_file_path}\"\r\n",
							"audio_filepath = f\"{curated_mount_path_cluster}/{pipeline_id}\"\r\n",
							"audio_filename = \"audio.wav\"\r\n",
							"\r\n",
							"audio = extract_audio_from_video(\r\n",
							"    video_filepath=video_filepath,\r\n",
							"    audio_filepath=audio_filepath,\r\n",
							"    audio_filename=audio_filename\r\n",
							")"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Speech to text"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import asyncio\r\n",
							"import httpx\r\n",
							"import time\r\n",
							"import uuid\r\n",
							"import logging\r\n",
							"import json\r\n",
							"\r\n",
							"from typing import List, Any\r\n",
							"from httpx import Response\r\n",
							"\r\n",
							"\r\n",
							"async def start_batch_transcription(azure_ai_speech_region: str, azure_ai_speech_key: str, azure_ai_speech_content_urls: List[str]) -> Response:\r\n",
							"    # Define url\r\n",
							"    base_url = f\"https://{azure_ai_speech_region}.api.cognitive.microsoft.com\"\r\n",
							"    transcription_url = f\"{base_url}/speechtotext/v3.2-preview.1/transcriptions\"\r\n",
							"    # model_url = f\"{base_url}/speechtotext/v3.2-preview.1/models/base/3765174c-b02f-40ba-bb4b-cd2332ec8a2e\"\r\n",
							"\r\n",
							"    # Define headers\r\n",
							"    headers = {\r\n",
							"        \"Content-Type\": \"application/json\",\r\n",
							"        \"Ocp-Apim-Subscription-Key\": azure_ai_speech_key,\r\n",
							"    }\r\n",
							"\r\n",
							"    # Define body\r\n",
							"    body = {\r\n",
							"        \"displayName\": f\"{uuid.uuid4()}\",\r\n",
							"        \"description\": \"STT for files\",\r\n",
							"        \"locale\": \"de-DE\",\r\n",
							"        \"contentUrls\": azure_ai_speech_content_urls,\r\n",
							"        # \"channels\": [0, 1],\r\n",
							"        # \"contentContainerUrl\": \"https://tstsynapsestg.blob.core.windows.net/audio\", # azure_ai_speech_content_container_url,\r\n",
							"        # \"model\": {\r\n",
							"        #     \"self\": model_url\r\n",
							"        # },\r\n",
							"        \"properties\": {\r\n",
							"            # \"languageIdentification\": {\r\n",
							"            #     \"candidateLocales\": [\"en-US\", \"de-DE\", \"es-ES\"]\r\n",
							"            # },\r\n",
							"            # \"destinationContainerUrl\": azure_ai_speech_sink_container_url, # TODO: Specify container sink to store result on customer storage\r\n",
							"            \"wordLevelTimestampsEnabled\": False,\r\n",
							"            \"displayFormWordLevelTimestampsEnabled\": True,\r\n",
							"            \"diarizationEnabled\": False,\r\n",
							"            # \"diarization\": 1,\r\n",
							"            \"punctuationMode\": \"DictatedAndAutomatic\",\r\n",
							"            \"profanityFilterMode\": \"None\",\r\n",
							"            \"timeToLive\": \"PT12H\"\r\n",
							"        },\r\n",
							"        \"customProperties\": {}\r\n",
							"    }\r\n",
							"\r\n",
							"    async with httpx.AsyncClient() as client:\r\n",
							"        response = await client.post(url=transcription_url, headers=headers, json=body)\r\n",
							"    return response\r\n",
							"\r\n",
							"\r\n",
							"async def get_batch_transcription_status(azure_ai_speech_region: str, azure_ai_speech_key: str, azure_ai_speech_transcription_id: str) -> Response:\r\n",
							"    # Define url\r\n",
							"    base_url = f\"https://{azure_ai_speech_region}.api.cognitive.microsoft.com\"\r\n",
							"    transcription_url = f\"{base_url}/speechtotext/v3.1/transcriptions/{azure_ai_speech_transcription_id}\"\r\n",
							"    \r\n",
							"    # Define headers\r\n",
							"    headers = {\r\n",
							"        \"Ocp-Apim-Subscription-Key\": azure_ai_speech_key,\r\n",
							"    }\r\n",
							"\r\n",
							"    async with httpx.AsyncClient() as client:\r\n",
							"        response = await client.get(url=transcription_url, headers=headers)\r\n",
							"    return response\r\n",
							"\r\n",
							"\r\n",
							"async def get_batch_transcription_result(azure_ai_speech_region: str, azure_ai_speech_key: str, azure_ai_speech_transcription_id: str) -> Response:\r\n",
							"    # Define url\r\n",
							"    base_url = f\"https://{azure_ai_speech_region}.api.cognitive.microsoft.com\"\r\n",
							"    transcription_url = f\"{base_url}/speechtotext/v3.1/transcriptions/{azure_ai_speech_transcription_id}/files\"\r\n",
							"    \r\n",
							"    # Define headers\r\n",
							"    headers = {\r\n",
							"        \"Ocp-Apim-Subscription-Key\": azure_ai_speech_key,\r\n",
							"    }\r\n",
							"\r\n",
							"    async with httpx.AsyncClient() as client:\r\n",
							"        response = await client.get(url=transcription_url, headers=headers)\r\n",
							"    return response\r\n",
							"\r\n",
							"\r\n",
							"async def azure_ai_speech_transcription(azure_ai_speech_region: str, azure_ai_speech_key: str, azure_ai_speech_content_urls: List[str], stt_filepath: str) -> List[Any]:\r\n",
							"    # Start batch transcription\r\n",
							"    response_start_batch_transcription = await start_batch_transcription(\r\n",
							"        azure_ai_speech_region=azure_ai_speech_region,\r\n",
							"        azure_ai_speech_key=azure_ai_speech_key,\r\n",
							"        azure_ai_speech_content_urls=azure_ai_speech_content_urls,\r\n",
							"    )\r\n",
							"    logging.debug(response_start_batch_transcription.json())\r\n",
							"    print(response_start_batch_transcription.json())\r\n",
							"\r\n",
							"    # Extract transcription id\r\n",
							"    transaction_id_url = response_start_batch_transcription.json().get(\"self\")\r\n",
							"    transcription_id = str.split(transaction_id_url, sep=\"/\")[-1]\r\n",
							"    logging.debug(f\"Transcription ID: {transcription_id}\")\r\n",
							"\r\n",
							"    # Check porcessing status\r\n",
							"    status = \"Unknown\"\r\n",
							"    while status not in [\"Succeeded\", \"Failed\", None]:\r\n",
							"        await asyncio.sleep(0.5)\r\n",
							"        response_batch_transcription_status = await get_batch_transcription_status(\r\n",
							"            azure_ai_speech_region=azure_ai_speech_region,\r\n",
							"            azure_ai_speech_key=azure_ai_speech_key,\r\n",
							"            azure_ai_speech_transcription_id=transcription_id,\r\n",
							"        )\r\n",
							"        if response_batch_transcription_status.status_code == 200:\r\n",
							"            status = response_batch_transcription_status.json().get(\"status\", None)\r\n",
							"        else:\r\n",
							"            status = None\r\n",
							"        print(f\"Processing Status: {status}\")\r\n",
							"        logging.info(f\"Processing Status: {status}\")\r\n",
							"    \r\n",
							"    # Get batch transcription result\r\n",
							"    response_batch_transcription_result = await get_batch_transcription_result(\r\n",
							"        azure_ai_speech_region=azure_ai_speech_region,\r\n",
							"        azure_ai_speech_key=azure_ai_speech_key,\r\n",
							"        azure_ai_speech_transcription_id=transcription_id,\r\n",
							"    )\r\n",
							"    print(response_batch_transcription_result.json())\r\n",
							"\r\n",
							"    # Get transcription file list\r\n",
							"    transcription_file_url_list = []\r\n",
							"    for value in response_batch_transcription_result.json().get(\"values\", []):\r\n",
							"        if value.get(\"kind\", \"\") == \"Transcription\":\r\n",
							"            transcription_file_url = value.get(\"links\", {\"contentUrl\": \"\"}).get(\"contentUrl\", None)\r\n",
							"            if transcription_file_url:\r\n",
							"                transcription_file_url_list.append(transcription_file_url)\r\n",
							"    \r\n",
							"    # Get transcription result content\r\n",
							"    transcription_content_list = []\r\n",
							"    for transcription_file_url in transcription_file_url_list:\r\n",
							"        async with httpx.AsyncClient() as client:\r\n",
							"            response = await client.get(url=transcription_file_url)\r\n",
							"        \r\n",
							"        transcription_content_list.append(response.json())\r\n",
							"    \r\n",
							"    # Save transcription result\r\n",
							"    os.makedirs(stt_filepath, exist_ok=True)\r\n",
							"    stt_filepath = os.path.join(stt_filepath, \"stt.json\")\r\n",
							"    with open(stt_filepath, mode=\"w\", encoding=\"utf8\") as f:\r\n",
							"        json.dump(transcription_content_list, f, ensure_ascii=False)\r\n",
							"\r\n",
							"    return transcription_content_list\r\n",
							""
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"azure_ai_speech_key = mssparkutils.credentials.getConnectionStringOrCreds(azure_ai_speech_linked_service_name)\r\n",
							"azure_ai_speech_content_url = f\"https://{curated_account_name}.blob.core.windows.net/{curated_container_name}/{pipeline_id}/{audio_filename}\"\r\n",
							"stt_filepath = f\"{curated_mount_path_cluster}/{pipeline_id}\"\r\n",
							"\r\n",
							"result_stt = await azure_ai_speech_transcription(\r\n",
							"    azure_ai_speech_region=azure_ai_speech_region,\r\n",
							"    azure_ai_speech_key=azure_ai_speech_key,\r\n",
							"    azure_ai_speech_content_urls=[\r\n",
							"        azure_ai_speech_content_url\r\n",
							"    ],\r\n",
							"    stt_filepath=stt_filepath\r\n",
							")\r\n",
							""
						],
						"outputs": [],
						"execution_count": 29
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"text_list = []\r\n",
							"\r\n",
							"for item in result_stt:\r\n",
							"    stt_result = item[\"combinedRecognizedPhrases\"][0][\"display\"]\r\n",
							"    text_list.append(stt_result)\r\n",
							""
						],
						"outputs": [],
						"execution_count": 40
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Open AI Summarization"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from langchain_openai import AzureChatOpenAI\r\n",
							"from langchain_core.messages import SystemMessage\r\n",
							"from langchain_core.prompts import ChatPromptTemplate\r\n",
							"from langchain_core.output_parsers import JsonOutputParser\r\n",
							"\r\n",
							"\r\n",
							"def invoke_llm(\r\n",
							"        azure_open_ai_key: str, \r\n",
							"        azure_open_ai_base_url: str, \r\n",
							"        azure_open_ai_api_version: str, \r\n",
							"        azure_open_ai_deployment_name: str, \r\n",
							"        news_content: str,\r\n",
							"        news_show_details: str,\r\n",
							"        oai_filepath: str) -> str:\r\n",
							"    # Create the chat template\r\n",
							"    system_message = \"\"\"\r\n",
							"    You are a world class assistent for summarizing news content.\r\n",
							"    You extract subsections from the provided news content and generate a title for each subsection.\r\n",
							"    You must include the start and end of the original text for each subsection in the response. The text snippet describing the beginning and end should include 5 words.\r\n",
							"    You add tags to each subsection. Samples for tags are: sports, weather, international news, national news, politics, technology, celebrity, other. You add additional tags based on the content of each subsection.\r\n",
							"    \r\n",
							"    You always respond with the following JSON structure:\r\n",
							"    [\r\n",
							"        {\r\n",
							"            \"title\": \"<title of the first subsection>\",\r\n",
							"            \"tags\": \"<tags of the first subsection>\",\r\n",
							"            \"start\": \"<start of the text of the first subsection from the original text>\",\r\n",
							"            \"end\": \"<end of the text of the first subsection from the original text>\"\r\n",
							"        },\r\n",
							"        {\r\n",
							"            \"title\": \"<title of the second subsection>\",\r\n",
							"            \"tags\": \"<tags of the second subsection>\",\r\n",
							"            \"start\": \"<start of the text of the second subsection from the original text>\",\r\n",
							"            \"end\": \"<end of the text of the second subsection from the original text>\"\r\n",
							"        },\r\n",
							"        {\r\n",
							"            \"title\": \"<title of the third subsection>\",\r\n",
							"            \"tags\": \"<tags of the third subsection>\",\r\n",
							"            \"start\": \"<start of the text of the third subsection from the original text>\",\r\n",
							"            \"end\": \"<end of the text of the third subsection from the original text>\"\r\n",
							"        }\r\n",
							"    ]\r\n",
							"    \"\"\"\r\n",
							"    user_message = \"\"\"\r\n",
							"    News Content: \"{news_content}\"\r\n",
							"    ---\r\n",
							"    Provide a summary for the provided news text. The text is about {news_show_details}\r\n",
							"    \"\"\"\r\n",
							"\r\n",
							"    prompt = ChatPromptTemplate.from_messages([\r\n",
							"        SystemMessage(content=system_message, type=\"system\"),\r\n",
							"        # (\"system\", system_message),\r\n",
							"        (\"user\", user_message)\r\n",
							"    ])\r\n",
							"    prompt.input_variables = [\"news_content\", \"news_show_details\"]\r\n",
							"\r\n",
							"    # Create the llm\r\n",
							"    llm = AzureChatOpenAI(\r\n",
							"        api_key=azure_open_ai_key,\r\n",
							"        azure_endpoint=azure_open_ai_base_url,\r\n",
							"        api_version=azure_open_ai_api_version,\r\n",
							"        deployment_name=azure_open_ai_deployment_name,\r\n",
							"    )\r\n",
							"\r\n",
							"    # Create the output parser\r\n",
							"    output_parser = JsonOutputParser() # TODO: Define pydantic model\r\n",
							"\r\n",
							"    # Create chain\r\n",
							"    chain = prompt | llm | output_parser\r\n",
							"\r\n",
							"    # invoke chain\r\n",
							"    result = chain.invoke(\r\n",
							"        {\r\n",
							"            \"news_content\": news_content,\r\n",
							"            \"news_show_details\": news_show_details\r\n",
							"        }\r\n",
							"    )\r\n",
							"\r\n",
							"    # Save transcription result\r\n",
							"    os.makedirs(oai_filepath, exist_ok=True)\r\n",
							"    oai_filepath = os.path.join(oai_filepath, \"aoai.json\")\r\n",
							"    with open(oai_filepath, mode=\"w\", encoding=\"utf8\") as f:\r\n",
							"        json.dump(result, f, ensure_ascii=False)\r\n",
							"\r\n",
							"    return result\r\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"azure_open_ai_key = mssparkutils.credentials.getConnectionStringOrCreds(azure_open_ai_linked_service_name)\r\n",
							"news_content = \" \".join(text_list)\r\n",
							"oai_filepath = f\"{curated_mount_path_cluster}/{pipeline_id}\"\r\n",
							"\r\n",
							"result_llm = invoke_llm(\r\n",
							"    azure_open_ai_key=azure_open_ai_key,\r\n",
							"    azure_open_ai_base_url=azure_open_ai_base_url,\r\n",
							"    azure_open_ai_api_version=azure_open_ai_api_version,\r\n",
							"    azure_open_ai_deployment_name=azure_open_ai_deployment_name,\r\n",
							"    azure_open_ai_model_name=azure_open_ai_model_name,\r\n",
							"    news_content=news_content,\r\n",
							"    news_show_details=news_show_details,\r\n",
							"    oai_filepath=oai_filepath\r\n",
							")"
						],
						"outputs": []
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Find timestamps in original result from STT for tagging"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import copy\r\n",
							"\r\n",
							"\r\n",
							"def get_word_details(result_stt: Any) -> List[Any]:\r\n",
							"    word_details = []\r\n",
							"    recognized_phrases = result_stt.get(\"recognizedPhrases\", [])\r\n",
							"\r\n",
							"    for recognized_phrase in recognized_phrases:\r\n",
							"        recognized_phrase_best = recognized_phrase.get(\"nBest\", [])[0]\r\n",
							"        recognized_phrase_best_display_words = recognized_phrase_best.get(\"displayWords\", [])\r\n",
							"\r\n",
							"        # Append word details\r\n",
							"        word_details.extend(recognized_phrase_best_display_words)\r\n",
							"    \r\n",
							"    return word_details\r\n",
							"\r\n",
							"def get_timestamps(result_stt: Any, result_llm: Any, timestamps_filepath: str) -> Any:\r\n",
							"    word_details = get_word_details(\r\n",
							"        result_stt=result_stt\r\n",
							"    )\r\n",
							"\r\n",
							"    # Configure indexes\r\n",
							"    result_llm_index = 0\r\n",
							"    result_llm_item = \"start\"\r\n",
							"\r\n",
							"    # Configure current item\r\n",
							"    result_llm_current_words = str(result_llm[result_llm_index].get(result_llm_item, None)).split(sep=\" \")\r\n",
							"\r\n",
							"    # Configure result\r\n",
							"    result = copy.deepcopy(result_llm)\r\n",
							"\r\n",
							"    for i, item in enumerate(word_details):\r\n",
							"        word_detail_display_text = item.get(\"displayText\")\r\n",
							"\r\n",
							"        if word_detail_display_text == result_llm_current_words[0]:\r\n",
							"            identical = [word == word_details[i+j].get(\"displayText\") for j, word in enumerate(result_llm_current_words)]\r\n",
							"            all_identical = all(identical)\r\n",
							"\r\n",
							"            if all_identical:\r\n",
							"                result[result_llm_index][f\"{result_llm_item}_offset\"] = word_details[i].get(\"offset\") if result_llm_item == \"start\" else word_details[i + len(result_llm_current_words) - 1].get(\"offset\")\r\n",
							"                \r\n",
							"                # print(word_detail_display_text)\r\n",
							"                # print(result[result_llm_index][f\"{result_llm_item}_offset\"])\r\n",
							"\r\n",
							"                # Update index\r\n",
							"                if result_llm_item == \"start\":\r\n",
							"                    result_llm_item = \"end\"\r\n",
							"                else:\r\n",
							"                    result_llm_index += 1\r\n",
							"                    result_llm_item = \"start\"\r\n",
							"\r\n",
							"                # Update current item\r\n",
							"                if result_llm_index < len(result_llm):\r\n",
							"                    result_llm_current_words = str(result_llm[result_llm_index].get(result_llm_item, None)).split(sep=\" \")\r\n",
							"                    # print(result_llm_current_words)\r\n",
							"                else:\r\n",
							"                    break\r\n",
							"    \r\n",
							"    # Save transcription result\r\n",
							"    os.makedirs(timestamps_filepath, exist_ok=True)\r\n",
							"    timestamps_filepath = os.path.join(timestamps_filepath, \"timestamps.json\")\r\n",
							"    with open(timestamps_filepath, mode=\"w\", encoding=\"utf8\") as f:\r\n",
							"        json.dump(result, f, ensure_ascii=False)\r\n",
							"\r\n",
							"    return result\r\n",
							""
						],
						"outputs": []
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"timestamps_filepath = f\"{curated_mount_path_cluster}/{pipeline_id}\"\r\n",
							"\r\n",
							"result_timestamp = get_timestamps(\r\n",
							"    result_stt=result_stt[0],\r\n",
							"    result_llm=result_llm,\r\n",
							"    timestamps_filepath=timestamps_filepath\r\n",
							")\r\n",
							""
						],
						"outputs": [],
						"execution_count": 34
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Unmount Datalake"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Unmount raw storage\r\n",
							"unmount_datalake_gen2(\r\n",
							"    mount_path=raw_mount_path,\r\n",
							")\r\n",
							"\r\n",
							"# Unmount curated storage\r\n",
							"unmount_datalake_gen2(\r\n",
							"    mount_path=curated_mount_path,\r\n",
							")\r\n",
							""
						],
						"outputs": [],
						"execution_count": 85
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/test')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": 15
				},
				"autoScale": {
					"enabled": true,
					"maxNodeCount": 10,
					"minNodeCount": 3
				},
				"nodeCount": 10,
				"nodeSize": "Medium",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "3.3",
				"libraryRequirements": {
					"content": "moviepy~=1.0.3\r\nhttpx~=0.27.0\r\nlangchain~=0.1.8\r\nlangchain-openai~=0.0.6\r\n",
					"filename": "requirements_mp.txt",
					"time": "2024-03-05T16:49:22.3659821Z"
				},
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": false,
				"annotations": []
			},
			"dependsOn": [],
			"location": "westeurope"
		}
	]
}